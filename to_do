* atomic updates for parts of records (one var)

* capped collections (limit by size, record number, etc.)
	* loop around at end
	* refuse write at end
	


*********************
Storage Possibilities
*********************

	* type storage - simple types only, translation implied manually
	* pipeline storage - storage template, load and dump functions
	* marshal storage


**************
Object Storage
**************

Overall Logic:

	* Objects consists in state
	* state is defined by variables
	* variables can be one of a number of underlying types (objects)
	* some of these types have additional type information
	* this type information consists in methods and variables
	* methods are stored in the meta-object (class or singleton)
	* the meta-object can be recreated from the source-code, which is presumed to be present
	* so we only have to address the storage of variables, which we have already said are one of a number of underlying types (objects)
	* so if we can deal with all objects in one context we can also deal with nested objects in the same way

Object Specifics:

	Simple Storage:
	
		T_NIL
		T_TRUE
		T_FALSE
		T_FIXNUM
		T_BIGNUM
		T_FLOAT
		T_COMPLEX
		T_RATIONAL
		T_SYMBOL
		T_STRING
		T_REGEXP
		T_MATCH
		T_FILE
		T_CLASS
		T_MODULE

	Complex Storage:

		T_OBJECT
		T_STRUCT

	Iterated Storage:

		T_ARRAY
		T_HASH

	Can Only be Partially Stored:

		T_DATA

Type Adapters:

	* can be used to specify how a given type is translated for storage
	* allows expansion of types
	* allows overriding of type handling for multiple possible handling of specific types
	* consist in a data storage map, a pipeline dump function, and a pipeline load function
